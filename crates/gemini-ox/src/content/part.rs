use bon::Builder;
use derive_more::{Deref, DerefMut};
use serde::{Deserialize, Serialize};
use serde_json::Value;

/// Represents a single part of a multi-part `Content` message.
///
/// Contains the core data (`PartData`) and optional metadata like `thought` and `video_metadata`.
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Deref, DerefMut)]
pub struct Part {
    /// Optional. Indicates if the part is thought from the model.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thought: Option<bool>,

    /// Optional. Metadata for a given video.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub video_metadata: Option<VideoMetadata>,

    /// The actual data payload of the part.
    #[serde(flatten)]
    #[deref]
    #[deref_mut]
    pub data: PartData,
}

impl Part {
    /// Creates a new `Part` with the given data and no thought or video metadata.
    pub fn new(data: impl Into<PartData>) -> Self {
        Self {
            thought: None,
            video_metadata: None,
            data: data.into(),
        }
    }

    /// Creates a new `Part` with the given data and thought information.
    pub fn new_with_thought(data: impl Into<PartData>, thought: bool) -> Self {
        Self {
            thought: Some(thought),
            video_metadata: None,
            data: data.into(),
        }
    }

    /// Creates a new `Part` with video metadata.
    pub fn new_with_video_metadata(data: impl Into<PartData>, metadata: VideoMetadata) -> Self {
        Self {
            thought: None,
            video_metadata: Some(metadata),
            data: data.into(),
        }
    }
}

/// Video metadata describing how the video in the Part should be used by the model.
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Builder)]
#[serde(rename_all = "camelCase")]
pub struct VideoMetadata {
    /// The frame rate of the video sent to the model. If not specified, the
    /// default value will be 1.0. The fps range is (0.0, 24.0].
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fps: Option<f32>,

    /// Optional. The start offset of the video.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start_offset: Option<String>,

    /// Optional. The end offset of the video.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end_offset: Option<String>,
}

impl VideoMetadata {
    pub fn new() -> Self {
        Self {
            fps: None,
            start_offset: None,
            end_offset: None,
        }
    }
}

impl Default for VideoMetadata {
    fn default() -> Self {
        Self::new()
    }
}

impl Eq for VideoMetadata {}

/// The core data types that can be included in a `Part`.
///
/// A `Part` consists of data which has an associated datatype. A `Part` can only
/// contain one of the accepted types in `Part.data`.
///
/// A `PartData` corresponding to inline data (`InlineData`) must have a fixed
/// IANA MIME type identifying the type and subtype of the media.
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub enum PartData {
    /// Inline text.
    Text(Text),
    /// Inline media bytes.
    InlineData(Blob),
    /// A predicted `FunctionCall` returned from the model that contains a string representing the
    /// `FunctionDeclaration.name` with the arguments and their values.
    FunctionCall(FunctionCall),
    /// The result output of a `FunctionCall` that contains a string representing the
    /// `FunctionDeclaration.name` and a structured JSON object containing any output from the
    /// function is used as context to the model.
    FunctionResponse(FunctionResponse),
    /// URI based data.
    FileData(FileData),
    /// Code generated by the model that is meant to be executed.
    ExecutableCode(ExecutableCode),
    /// Result of executing the `ExecutableCode`.
    CodeExecutionResult(CodeExecutionResult),
}

impl PartData {
    /// If the `PartData` is a `Text` variant, returns `Some(&Text)`; otherwise returns `None`.
    #[must_use]
    pub fn as_text(&self) -> Option<&Text> {
        match self {
            PartData::Text(text) => Some(text),
            _ => None,
        }
    }

    /// If the `PartData` is a `Text` variant, returns `Some(&mut Text)`; otherwise returns `None`.
    pub fn as_mut_text(&mut self) -> Option<&mut Text> {
        match self {
            PartData::Text(text) => Some(text),
            _ => None,
        }
    }

    /// If the `PartData` is an `InlineData` variant, returns `Some(&Blob)`; otherwise returns `None`.
    #[must_use]
    pub fn as_inline_data(&self) -> Option<&Blob> {
        match self {
            PartData::InlineData(inline_data) => Some(inline_data),
            _ => None,
        }
    }

    /// If the `PartData` is a `FunctionCall` variant, returns `Some(&FunctionCall)`; otherwise returns `None`.
    #[must_use]
    pub fn as_function_call(&self) -> Option<&FunctionCall> {
        match self {
            PartData::FunctionCall(function_call) => Some(function_call),
            _ => None,
        }
    }

    /// If the `PartData` is a `FunctionResponse` variant, returns `Some(&FunctionResponse)`; otherwise returns `None`.
    #[must_use]
    pub fn as_function_response(&self) -> Option<&FunctionResponse> {
        match self {
            PartData::FunctionResponse(function_response) => Some(function_response),
            _ => None,
        }
    }

    /// If the `PartData` is a `FileData` variant, returns `Some(&FileData)`; otherwise returns `None`.
    #[must_use]
    pub fn as_file_data(&self) -> Option<&FileData> {
        match self {
            PartData::FileData(file_data) => Some(file_data),
            _ => None,
        }
    }

    /// If the `PartData` is an `ExecutableCode` variant, returns `Some(&ExecutableCode)`; otherwise returns `None`.
    #[must_use]
    pub fn as_executable_code(&self) -> Option<&ExecutableCode> {
        match self {
            PartData::ExecutableCode(executable_code) => Some(executable_code),
            _ => None,
        }
    }

    /// If the `PartData` is a `CodeExecutionResult` variant, returns `Some(&CodeExecutionResult)`; otherwise returns `None`.
    #[must_use]
    pub fn as_code_execution_result(&self) -> Option<&CodeExecutionResult> {
        match self {
            PartData::CodeExecutionResult(code_execution_result) => Some(code_execution_result),
            _ => None,
        }
    }

    /// Consumes the `PartData`. If it is a `Text` variant, returns `Some(Text)`; otherwise returns `None`.
    #[must_use]
    pub fn into_text(self) -> Option<Text> {
        match self {
            PartData::Text(text) => Some(text),
            _ => None,
        }
    }

    /// Consumes the `PartData`. If it is an `InlineData` variant, returns `Some(Blob)`; otherwise returns `None`.
    #[must_use]
    pub fn into_inline_data(self) -> Option<Blob> {
        match self {
            PartData::InlineData(blob) => Some(blob),
            _ => None,
        }
    }

    /// Consumes the `PartData`. If it is a `FunctionCall` variant, returns `Some(FunctionCall)`; otherwise returns `None`.
    #[must_use]
    pub fn into_function_call(self) -> Option<FunctionCall> {
        match self {
            PartData::FunctionCall(call) => Some(call),
            _ => None,
        }
    }

    /// Consumes the `PartData`. If it is a `FunctionResponse` variant, returns `Some(FunctionResponse)`; otherwise returns `None`.
    #[must_use]
    pub fn into_function_response(self) -> Option<FunctionResponse> {
        match self {
            PartData::FunctionResponse(response) => Some(response),
            _ => None,
        }
    }

    /// Consumes the `PartData`. If it is a `FileData` variant, returns `Some(FileData)`; otherwise returns `None`.
    #[must_use]
    pub fn into_file_data(self) -> Option<FileData> {
        match self {
            PartData::FileData(data) => Some(data),
            _ => None,
        }
    }

    /// Consumes the `PartData`. If it is an `ExecutableCode` variant, returns `Some(ExecutableCode)`; otherwise returns `None`.
    #[must_use]
    pub fn into_executable_code(self) -> Option<ExecutableCode> {
        match self {
            PartData::ExecutableCode(code) => Some(code),
            _ => None,
        }
    }

    /// Consumes the `PartData`. If it is a `CodeExecutionResult` variant, returns `Some(CodeExecutionResult)`; otherwise returns `None`.
    #[must_use]
    pub fn into_code_execution_result(self) -> Option<CodeExecutionResult> {
        match self {
            PartData::CodeExecutionResult(result) => Some(result),
            _ => None,
        }
    }
}

// --- From implementations for PartData ---

/// Converts `Text` into a `PartData::Text`.
impl From<Text> for PartData {
    fn from(value: Text) -> Self {
        PartData::Text(value)
    }
}

/// Converts `Blob` into a `PartData::InlineData`.
impl From<Blob> for PartData {
    fn from(value: Blob) -> Self {
        Self::InlineData(value)
    }
}

/// Converts `FunctionCall` into a `PartData::FunctionCall`.
impl From<FunctionCall> for PartData {
    fn from(function_call: FunctionCall) -> Self {
        Self::FunctionCall(function_call)
    }
}

/// Converts `FunctionResponse` into a `PartData::FunctionResponse`.
impl From<FunctionResponse> for PartData {
    fn from(function_response: FunctionResponse) -> Self {
        Self::FunctionResponse(function_response)
    }
}

/// Converts `FileData` into a `PartData::FileData`.
impl From<FileData> for PartData {
    fn from(file_data: FileData) -> Self {
        Self::FileData(file_data)
    }
}

/// Converts `ExecutableCode` into a `PartData::ExecutableCode`.
impl From<ExecutableCode> for PartData {
    fn from(executable_code: ExecutableCode) -> Self {
        Self::ExecutableCode(executable_code)
    }
}

/// Converts `CodeExecutionResult` into a `PartData::CodeExecutionResult`.
impl From<CodeExecutionResult> for PartData {
    fn from(code_execution_result: CodeExecutionResult) -> Self {
        Self::CodeExecutionResult(code_execution_result)
    }
}

/// Converts a string slice into a `PartData::Text`.
impl From<&str> for PartData {
    fn from(value: &str) -> Self {
        Self::Text(Text::from(value))
    }
}

/// Converts a `String` into a `PartData::Text`.
impl From<String> for PartData {
    fn from(value: String) -> Self {
        Self::Text(Text::from(value))
    }
}

/// Converts a `serde_json::Value` into a `PartData::Text` by converting the value to its string representation.
/// Note: This might not always be the intended conversion. Consider if a more structured PartData variant is appropriate.
impl From<Value> for PartData {
    fn from(value: Value) -> Self {
        Self::Text(Text::from(value.to_string()))
    }
}

// --- Convenience From implementations for Part ---

/// Converts any `PartData` variant into a `Part` with `thought: None`.
impl<T: Into<PartData>> From<T> for Part {
    fn from(value: T) -> Self {
        Part::new(value.into())
    }
}

// --- Data Struct Definitions ---

/// Represents inline text content.
#[derive(
    Debug, Serialize, Deserialize, Clone, PartialEq, Eq, derive_more::Deref, derive_more::Display,
)]
pub struct Text(String);

impl Text {
    /// Creates new `Text` from anything convertible to a `String`.
    pub fn new(content: impl Into<String>) -> Self {
        Text(content.into())
    }

    /// Appends text from another `Text` instance to this one.
    pub fn push_text(&mut self, other: &Text) {
        self.0.push_str(&other.0);
    }
}

/// Converts any type implementing `Into<String>` into `Text`.
impl<T> From<T> for Text
where
    T: Into<String>,
{
    fn from(value: T) -> Self {
        Text(value.into())
    }
}

/// Blob (Content blob)
///
/// Raw media bytes.
/// Text should not be sent as raw bytes, use the 'text' field.
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct Blob {
    /// Required. The IANA standard MIME type of the source data.
    pub mime_type: String,
    /// Required. Raw bytes for media formats. A base64-encoded string.
    pub data: String,
    /// Optional. Display name of the blob. Used to provide a label or filename to distinguish blobs.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,
}

impl Blob {
    /// Create a new Blob.
    pub fn new(mime_type: impl Into<String>, data: impl Into<String>) -> Self {
        Self {
            mime_type: mime_type.into(),
            data: data.into(),
            display_name: None,
        }
    }

    /// Create a new Blob with display name.
    pub fn new_with_display_name(
        mime_type: impl Into<String>,
        data: impl Into<String>,
        display_name: impl Into<String>,
    ) -> Self {
        Self {
            mime_type: mime_type.into(),
            data: data.into(),
            display_name: Some(display_name.into()),
        }
    }
}

/// FunctionCall
///
/// A predicted FunctionCall returned from the model that contains a string representing the
/// FunctionDeclaration.name with the arguments and their values.
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct FunctionCall {
    /// The unique id of the function call. If populated, the client to execute the
    /// `function_call` and return the response with the matching `id`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Required. The name of the function to call. Must be a-z, A-Z, 0-9, or contain
    /// underscores and dashes, with a maximum length of 63.
    pub name: String,
    /// Optional. The function parameters and values in JSON object format.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub args: Option<Value>,
}

impl FunctionCall {
    /// Create a new FunctionCall without an ID.
    pub fn new(name: impl Into<String>, args: Option<Value>) -> Self {
        Self {
            id: None,
            name: name.into(),
            args,
        }
    }

    /// Create a new FunctionCall with an ID.
    pub fn new_with_id(
        id: impl Into<String>,
        name: impl Into<String>,
        args: Option<Value>,
    ) -> Self {
        Self {
            id: Some(id.into()),
            name: name.into(),
            args,
        }
    }
}

/// Enumeration for function response scheduling.
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
pub enum FunctionResponseScheduling {
    /// This value is unused.
    #[serde(rename = "SCHEDULING_UNSPECIFIED")]
    Unspecified,
    /// Only add the result to the conversation context, do not interrupt or trigger generation.
    #[serde(rename = "SILENT")]
    Silent,
    /// Add the result to the conversation context, and prompt to generate output without interrupting ongoing generation.
    #[serde(rename = "WHEN_IDLE")]
    WhenIdle,
    /// Add the result to the conversation context, interrupt ongoing generation and prompt to generate output.
    #[serde(rename = "INTERRUPT")]
    Interrupt,
}

/// FunctionResponse
///
/// The result output from a `FunctionCall`. This should contain the result of a
/// FunctionCall made based on model prediction. It contains the name of the function
/// that was called and the structured JSON object containing the result of the function execution.
/// This is used as context to the model.
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct FunctionResponse {
    /// Optional. The id of the function call this response is for. Populated by the client to match the corresponding function call `id`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Required. The name of the function that was called. Must be a-z, A-Z, 0-9, or contain
    /// underscores and dashes, with a maximum length of 63. Corresponds to FunctionCall.name.
    pub name: String,
    /// Required. The function response in JSON object format.
    pub response: Value,
    /// Signals that function call continues, and more responses will be returned, turning the function call into a generator.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub will_continue: Option<bool>,
    /// Specifies how the response should be scheduled in the conversation.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduling: Option<FunctionResponseScheduling>,
}

impl FunctionResponse {
    /// Create a new FunctionResponse, serializing the response data into a `serde_json::Value`.
    /// Panics if `response` cannot be serialized to a `Value`.
    pub fn new(name: impl Into<String>, response: impl Serialize) -> Self {
        Self {
            id: None,
            name: name.into(),
            response: serde_json::to_value(response)
                .expect("Failed to serialize response to JSON Value"),
            will_continue: None,
            scheduling: None,
        }
    }

    /// Create a new FunctionResponse with an ID.
    pub fn new_with_id(
        id: impl Into<String>,
        name: impl Into<String>,
        response: impl Serialize,
    ) -> Self {
        Self {
            id: Some(id.into()),
            name: name.into(),
            response: serde_json::to_value(response)
                .expect("Failed to serialize response to JSON Value"),
            will_continue: None,
            scheduling: None,
        }
    }

    /// Create a new FunctionResponse with continuation support.
    pub fn new_with_continuation(
        name: impl Into<String>,
        response: impl Serialize,
        will_continue: bool,
        scheduling: Option<FunctionResponseScheduling>,
    ) -> Self {
        Self {
            id: None,
            name: name.into(),
            response: serde_json::to_value(response)
                .expect("Failed to serialize response to JSON Value"),
            will_continue: Some(will_continue),
            scheduling,
        }
    }
}

/// FileData
///
/// URI based data reference.
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct FileData {
    /// Required. URI identifying the file.
    pub file_uri: String,
    /// Required. The IANA standard MIME type of the source data.
    pub mime_type: String,
    /// Optional. Display name of the file data. Used to provide a label or filename to distinguish file datas.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,
}

impl FileData {
    /// Create a new FileData.
    pub fn new(file_uri: impl Into<String>, mime_type: impl Into<String>) -> Self {
        Self {
            file_uri: file_uri.into(),
            mime_type: mime_type.into(),
            display_name: None,
        }
    }

    /// Create a new FileData with optional mime type.
    pub fn new_with_optional_mime_type(
        file_uri: impl Into<String>,
        mime_type: Option<impl Into<String>>,
    ) -> Self {
        Self {
            file_uri: file_uri.into(),
            mime_type: mime_type.map(Into::into).unwrap_or_default(),
            display_name: None,
        }
    }

    /// Create a new FileData with display name.
    pub fn new_with_display_name(
        file_uri: impl Into<String>,
        mime_type: impl Into<String>,
        display_name: impl Into<String>,
    ) -> Self {
        Self {
            file_uri: file_uri.into(),
            mime_type: mime_type.into(),
            display_name: Some(display_name.into()),
        }
    }
}

/// Programming language for executable code.
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, strum::Display)]
pub enum Language {
    /// Unspecified language. This value should not be used.
    #[serde(rename = "LANGUAGE_UNSPECIFIED")]
    Unspecified,
    /// Python >= 3.10, with numpy and simpy available.
    #[serde(rename = "PYTHON")]
    Python,
}

/// ExecutableCode
///
/// Code generated by the model that is meant to be executed.
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Builder)]
#[serde(rename_all = "camelCase")]
pub struct ExecutableCode {
    /// Required. Programming language of the `code`.
    pub language: Language,
    /// Required. The code to be executed.
    pub code: String,
}

impl ExecutableCode {
    /// Create new ExecutableCode.
    pub fn new(language: Language, code: impl Into<String>) -> Self {
        Self {
            language,
            code: code.into(),
        }
    }
}

/// Enumeration of possible outcomes of the code execution.
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, strum::Display)]
pub enum Outcome {
    /// Unspecified status. This value should not be used.
    #[serde(rename = "OUTCOME_UNSPECIFIED")]
    Unspecified,
    /// Code execution completed successfully.
    #[serde(rename = "OUTCOME_OK")]
    Ok,
    /// Code execution finished but with a failure. stderr should contain the reason.
    #[serde(rename = "OUTCOME_FAILED")]
    Failed,
    /// Code execution ran for too long, and was cancelled. There may or may not be a partial output present.
    #[serde(rename = "OUTCOME_DEADLINE_EXCEEDED")]
    DeadlineExceeded,
}

/// CodeExecutionResult
///
/// Result of executing the `ExecutableCode`.
/// Always follows a `part` containing the `ExecutableCode`.
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct CodeExecutionResult {
    /// Required. Outcome of the code execution.
    pub outcome: Outcome,
    /// Optional. Contains stdout when code execution is successful, stderr or other description otherwise.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub output: Option<String>,
}

impl CodeExecutionResult {
    /// Create new CodeExecutionResult.
    pub fn new(outcome: Outcome, output: Option<impl Into<String>>) -> Self {
        Self {
            outcome,
            output: output.map(Into::into),
        }
    }
}
