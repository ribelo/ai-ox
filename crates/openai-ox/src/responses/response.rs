use crate::Usage;
use ai_ox_common::openai_format::ToolCall;
use ai_ox_common::usage::TokenUsage;
use serde::{Deserialize, Serialize};

/// Error object returned when the model fails to generate a Response
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResponseError {
    /// Error code
    pub code: String,
    /// Error message
    pub message: String,
    /// Additional error parameters
    #[serde(skip_serializing_if = "Option::is_none")]
    pub param: Option<String>,
    /// Error type
    #[serde(skip_serializing_if = "Option::is_none")]
    pub r#type: Option<String>,
}

/// Details about why the response is incomplete
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IncompleteDetails {
    /// The reason why the response is incomplete
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>, // "max_output_tokens" or "content_filter"
}

/// The conversation that this response belongs to
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Conversation {
    /// The unique ID of the conversation
    pub id: String,
}

/// Response from OpenAI Responses API - matches official SDK 1:1
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResponsesResponse {
    /// Unique identifier for this Response
    pub id: String,

    /// Unix timestamp (in seconds) of when this Response was created
    pub created_at: u64,

    /// Extracted text content from the response output (SDK adds this field)
    #[serde(skip_deserializing, default)]
    pub output_text: String,

    /// An error object returned when the model fails to generate a Response
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ResponseError>,

    /// Details about why the response is incomplete
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incomplete_details: Option<IncompleteDetails>,

    /// A system (or developer) message inserted into the model's context
    #[serde(skip_serializing_if = "Option::is_none")]
    pub instructions: Option<serde_json::Value>, // Can be string or array

    /// Set of 16 key-value pairs that can be attached to an object
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<serde_json::Value>,

    /// Model ID used to generate the response
    pub model: String,

    /// The object type of this resource - always set to `response`
    pub object: String, // Always "response"

    /// An array of content items generated by the model
    pub output: Vec<ResponseOutputItem>,

    /// Whether to allow the model to run tool calls in parallel
    pub parallel_tool_calls: bool,

    /// What sampling temperature to use, between 0 and 2
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temperature: Option<f32>,

    /// How the model should select which tool (or tools) to use
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_choice: Option<serde_json::Value>,

    /// An array of tools the model may call
    pub tools: Vec<serde_json::Value>,

    /// Alternative to sampling with temperature, called nucleus sampling
    #[serde(skip_serializing_if = "Option::is_none")]
    pub top_p: Option<f32>,

    /// Whether to run the model response in the background
    #[serde(skip_serializing_if = "Option::is_none")]
    pub background: Option<bool>,

    /// The conversation that this response belongs to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conversation: Option<Conversation>,

    /// An upper bound for the number of tokens that can be generated
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_output_tokens: Option<u32>,

    /// The unique ID of the previous response to the model
    #[serde(skip_serializing_if = "Option::is_none")]
    pub previous_response_id: Option<String>,

    /// A stable identifier for your end-users
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prompt_cache_key: Option<String>,

    /// Maximum tool calls allowed
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_tool_calls: Option<u32>,

    /// Service tier information
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_tier: Option<String>,

    /// Number of top logprobs to return
    #[serde(skip_serializing_if = "Option::is_none", default)]
    pub top_logprobs: Option<u32>,

    /// Configuration options for reasoning models
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reasoning: Option<serde_json::Value>,

    /// Safety identifier for abuse detection and prevention
    #[serde(skip_serializing_if = "Option::is_none")]
    pub safety_identifier: Option<String>,

    /// The status of the response generation
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>, // "completed", "failed", "in_progress", etc.

    /// Configuration options for a text response from the model
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<serde_json::Value>,

    /// The truncation strategy to use for the model response
    #[serde(skip_serializing_if = "Option::is_none")]
    pub truncation: Option<String>, // "auto" or "disabled"

    /// Token usage details
    #[serde(skip_serializing_if = "Option::is_none")]
    pub usage: Option<ResponsesUsage>,

    /// User identifier (deprecated, use safety_identifier instead)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// Individual output item in the response - matches official SDK 1:1
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ResponseOutputItem {
    /// Message response from the assistant
    #[serde(rename = "message")]
    Message {
        /// The unique ID of the output message
        id: String,
        /// The content of the output message
        content: Vec<ResponseOutputContent>,
        /// The role of the output message. Always "assistant"
        role: String, // Always "assistant"
        /// The status of the message
        status: String, // "in_progress", "completed", "incomplete"
    },

    /// Reasoning item containing the model's internal reasoning
    #[serde(rename = "reasoning")]
    Reasoning {
        /// The unique identifier of the reasoning content
        id: String,
        /// Reasoning summary content
        summary: Vec<serde_json::Value>,
        /// Reasoning text content (optional)
        #[serde(skip_serializing_if = "Option::is_none")]
        content: Option<Vec<serde_json::Value>>,
    },

    /// File search tool call
    #[serde(rename = "file_search_tool_call")]
    FileSearchToolCall {
        id: String,
        #[serde(flatten)]
        details: serde_json::Value,
    },

    /// Function tool call
    #[serde(rename = "function_tool_call")]
    FunctionToolCall {
        id: String,
        #[serde(flatten)]
        details: serde_json::Value,
    },

    /// Computer tool call
    #[serde(rename = "computer_tool_call")]
    ComputerToolCall {
        id: String,
        #[serde(flatten)]
        details: serde_json::Value,
    },

    /// Code interpreter tool call
    #[serde(rename = "code_interpreter_tool_call")]
    CodeInterpreterToolCall {
        id: String,
        #[serde(flatten)]
        details: serde_json::Value,
    },

    /// Custom tool call
    #[serde(rename = "custom_tool_call")]
    CustomToolCall {
        id: String,
        #[serde(flatten)]
        details: serde_json::Value,
    },
}

/// Content types that can appear in a response output message
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ResponseOutputContent {
    /// Text output with annotations
    #[serde(rename = "text")]
    Text {
        /// The text output from the model
        text: String,
        /// The annotations of the text output
        #[serde(default)]
        annotations: Vec<serde_json::Value>,
    },

    /// Refusal from the model
    #[serde(rename = "refusal")]
    Refusal {
        /// The refusal message
        refusal: String,
    },
}

/// Reasoning item containing the model's internal reasoning
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReasoningItem {
    /// Unique identifier for this reasoning item
    pub id: String,

    /// Human-readable summary of the reasoning (if requested)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,

    /// Encrypted reasoning content for ZDR compliance
    #[serde(skip_serializing_if = "Option::is_none")]
    pub encrypted_content: Option<String>,

    /// Token usage for this reasoning
    #[serde(skip_serializing_if = "Option::is_none")]
    pub usage: Option<ReasoningUsage>,
}

/// Message response item
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResponseMessage {
    /// Message role (typically "assistant")
    pub role: String,

    /// Message content
    pub content: String,

    /// Tool calls in this message (if any)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_calls: Option<Vec<ToolCall>>,
}

/// Tool call item
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolCallItem {
    /// Tool call details
    #[serde(flatten)]
    pub tool_call: ToolCall,

    /// Result of the tool call (if completed)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<String>,

    /// Status of the tool call
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// Text item for simple text responses
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextItem {
    /// Text content
    pub text: String,
}

/// Usage statistics for Responses API
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResponsesUsage {
    /// Total input tokens
    pub input_tokens: u32,

    /// Total output tokens
    pub output_tokens: u32,

    /// Total tokens used
    pub total_tokens: u32,

    /// Detailed input token breakdown
    #[serde(skip_serializing_if = "Option::is_none")]
    pub input_tokens_details: Option<InputTokensDetails>,

    /// Detailed output token breakdown
    #[serde(skip_serializing_if = "Option::is_none")]
    pub output_tokens_details: Option<OutputTokensDetails>,

    /// Reasoning tokens used (deprecated, use output_tokens_details)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reasoning_tokens: Option<u32>,

    /// Cache-related token details
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cache: Option<CacheUsage>,
}

/// Detailed input token breakdown
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputTokensDetails {
    /// Number of cached tokens
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cached_tokens: Option<u32>,
}

/// Detailed output token breakdown
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OutputTokensDetails {
    /// Number of reasoning tokens
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reasoning_tokens: Option<u32>,
}

/// Cache usage details
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CacheUsage {
    /// Cached input tokens
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cached_input_tokens: Option<u32>,

    /// Cache hit rate
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hit_rate: Option<f64>,
}

/// Usage statistics for individual reasoning items
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReasoningUsage {
    /// Tokens used in this reasoning step
    pub reasoning_tokens: u32,
}

/// Streaming response for Responses API
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResponsesStreamChunk {
    /// Chunk identifier
    pub id: String,

    /// Model used
    pub model: String,

    /// Output delta for this chunk
    pub output: Vec<OutputDelta>,

    /// Current status
    pub status: String,

    /// Final usage (only in last chunk)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub usage: Option<ResponsesUsage>,
}

/// Delta for streaming output items
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum OutputDelta {
    /// Reasoning delta
    #[serde(rename = "reasoning")]
    ReasoningDelta(ReasoningDelta),

    /// Message delta
    #[serde(rename = "message")]
    MessageDelta(MessageDelta),

    /// Tool call delta
    #[serde(rename = "tool_call")]
    ToolCallDelta(ToolCallDelta),

    /// Text delta
    #[serde(rename = "text")]
    TextDelta(TextDelta),
}

/// Reasoning delta for streaming
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReasoningDelta {
    /// Reasoning item ID
    pub id: String,

    /// Partial summary update
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,

    /// Partial encrypted content update
    #[serde(skip_serializing_if = "Option::is_none")]
    pub encrypted_content: Option<String>,
}

/// Message delta for streaming
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageDelta {
    /// Role (if starting new message)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,

    /// Partial content
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content: Option<String>,

    /// Tool call deltas
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_calls: Option<Vec<ToolCallDelta>>,
}

/// Tool call delta for streaming
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolCallDelta {
    /// Tool call index
    pub index: u32,

    /// Tool call ID
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// Function name
    #[serde(skip_serializing_if = "Option::is_none")]
    pub function: Option<String>,

    /// Partial arguments
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arguments: Option<String>,
}

/// Text delta for streaming
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextDelta {
    /// Partial text content
    pub text: String,
}

// Helper function to add output_text field like the official SDK does
pub fn add_output_text(response: &mut ResponsesResponse) {
    let mut texts = Vec::new();

    for output in &response.output {
        if let ResponseOutputItem::Message { content, .. } = output {
            for content_item in content {
                if let ResponseOutputContent::Text { text, .. } = content_item {
                    texts.push(text.clone());
                }
            }
        }
    }

    response.output_text = texts.join("");
}

// Helper methods for ResponsesResponse
impl ResponsesResponse {
    /// Get the main text content from the response
    pub fn content(&self) -> Option<String> {
        // Use output_text if available (matches official SDK behavior)
        if !self.output_text.is_empty() {
            return Some(self.output_text.clone());
        }

        // Fallback: extract from output items
        let mut content_parts = Vec::new();

        for item in &self.output {
            match item {
                ResponseOutputItem::Message { content, .. } => {
                    for msg_content in content {
                        match msg_content {
                            ResponseOutputContent::Text { text, .. } => {
                                content_parts.push(text.clone());
                            }
                            ResponseOutputContent::Refusal { refusal } => {
                                content_parts.push(format!("[Refusal: {}]", refusal));
                            }
                        }
                    }
                }
                ResponseOutputItem::Reasoning { summary, .. } => {
                    for val in summary {
                        if let Some(s) = val.as_str() {
                            content_parts.push(s.to_string());
                        }
                    }
                }
                _ => {}
            }
        }

        if content_parts.is_empty() {
            None
        } else {
            Some(content_parts.join("\n"))
        }
    }

    /// Get all reasoning items from the response
    pub fn reasoning_items(&self) -> Vec<(&str, &Vec<serde_json::Value>)> {
        self.output
            .iter()
            .filter_map(|item| match item {
                ResponseOutputItem::Reasoning { id, summary, .. } => Some((id.as_str(), summary)),
                _ => None,
            })
            .collect()
    }

    /// Get all messages from the response
    pub fn messages(&self) -> Vec<(&str, &str, &Vec<ResponseOutputContent>)> {
        self.output
            .iter()
            .filter_map(|item| match item {
                ResponseOutputItem::Message {
                    id, role, content, ..
                } => Some((id.as_str(), role.as_str(), content)),
                _ => None,
            })
            .collect()
    }

    /// Get all tool calls from the response
    pub fn tool_calls(&self) -> Vec<(&str, &serde_json::Value)> {
        self.output
            .iter()
            .filter_map(|item| match item {
                ResponseOutputItem::FunctionToolCall { id, details }
                | ResponseOutputItem::FileSearchToolCall { id, details }
                | ResponseOutputItem::ComputerToolCall { id, details }
                | ResponseOutputItem::CodeInterpreterToolCall { id, details }
                | ResponseOutputItem::CustomToolCall { id, details } => {
                    Some((id.as_str(), details))
                }
                _ => None,
            })
            .collect()
    }

    /// Check if the response is completed
    pub fn is_completed(&self) -> bool {
        self.status.as_deref() == Some("completed")
    }

    /// Check if the response is still in progress
    pub fn is_in_progress(&self) -> bool {
        self.status.as_deref() == Some("in_progress")
    }

    /// Check if the response failed
    pub fn is_failed(&self) -> bool {
        self.status.as_deref() == Some("failed")
    }

    /// Get total reasoning tokens used
    pub fn reasoning_tokens(&self) -> u32 {
        self.usage
            .as_ref()
            .and_then(|u| u.reasoning_tokens)
            .unwrap_or(0)
    }

    /// Check if response contains reasoning content
    pub fn has_reasoning(&self) -> bool {
        self.reasoning_items()
            .iter()
            .any(|(_, summary)| !summary.is_empty())
    }
}

// Conversion from ResponsesUsage to standard Usage
impl From<ResponsesUsage> for Usage {
    fn from(responses_usage: ResponsesUsage) -> Self {
        Self {
            tokens: TokenUsage {
                prompt_tokens: Some(responses_usage.input_tokens as u64),
                completion_tokens: Some(responses_usage.output_tokens as u64),
                total_tokens: Some(responses_usage.total_tokens as u64),
                cache_creation_tokens: None,
                cache_read_tokens: None,
                reasoning_tokens: responses_usage.reasoning_tokens.map(|t| t as u64),
                tool_prompt_tokens: None,
                thoughts_tokens: None,
            },
            prompt_tokens_details: None,
            completion_tokens_details: responses_usage.reasoning_tokens.map(|reasoning_tokens| {
                crate::usage::CompletionTokensDetails {
                    reasoning_tokens: Some(reasoning_tokens as u64),
                    audio_tokens: None,
                }
            }),
        }
    }
}

// Conversion from standard Usage to ResponsesUsage
impl From<Usage> for ResponsesUsage {
    fn from(usage: Usage) -> Self {
        Self {
            input_tokens: usage.prompt_tokens() as u32,
            output_tokens: usage.completion_tokens() as u32,
            total_tokens: usage.total_tokens() as u32,
            input_tokens_details: None,
            output_tokens_details: None,
            reasoning_tokens: usage.tokens.reasoning_tokens.map(|t| t as u32),
            cache: None,
        }
    }
}
