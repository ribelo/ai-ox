use super::part::Part;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use serde_json::Value;

/// The role of a message in a conversation.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum MessageRole {
    /// User messages represent input from the human user.
    User,
    /// Assistant messages are responses generated by the AI model.
    Assistant,
}

/// Represents a single message in a conversation.
/// Each message has a role and can contain multiple content parts.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Message {
    /// The role of the entity that sent this message.
    pub role: MessageRole,
    /// The content parts that make up this message.
    /// Can include text, images, tool calls, and tool results.
    pub content: Vec<Part>,
    /// The timestamp of the message.
    pub timestamp: DateTime<Utc>,
}

impl Message {
    /// Creates a new Message with the given role and content.
    pub fn new(role: MessageRole, content: Vec<Part>) -> Self {
        Self {
            role,
            content,
            timestamp: Utc::now(),
        }
    }
    
    /// Creates a Message containing a tool response.
    /// This is used to represent the result of a tool execution.
    pub fn from_tool_response(tool_call_id: String, tool_name: String, response_data: Value) -> Self {
        Self {
            role: MessageRole::Assistant,
            content: vec![Part::ToolResult {
                call_id: tool_call_id,
                name: tool_name,
                content: response_data,
            }],
            timestamp: Utc::now(),
        }
    }
}

/// Implements IntoIterator for Message to allow passing single messages
/// to functions expecting iterators.
impl IntoIterator for Message {
    type Item = Message;
    type IntoIter = std::iter::Once<Message>;

    fn into_iter(self) -> Self::IntoIter {
        std::iter::once(self)
    }
}
