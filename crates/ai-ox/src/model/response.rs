//! Defines the canonical model responses used for all model interactions.

use crate::content::Part;
use crate::content::message::Message;
use crate::tool::ToolUse;
use crate::usage::Usage;
use serde::{Deserialize, Serialize};
use serde_json::Value;

/// Represents a response from a model after generating content.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModelResponse {
    /// The message generated by the model.
    pub message: Message,

    /// The name of the model that generated the response.
    pub model_name: String,

    /// Token usage statistics for the request.
    pub usage: Usage,

    /// The name of the vendor that provides the model (e.g., "google").
    pub vendor_name: String,
}

/// A struct to hold the raw structured content from the model provider.
///
/// This is used internally to pass the essential data from the object-safe
/// part of the trait to the generic, user-facing methods.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RawStructuredResponse {
    /// The raw JSON value returned by the model.
    pub json: Value,
    /// The name of the vendor that provides the model (e.g., "google").
    pub vendor_name: String,

    /// The name of the model that generated the response.
    pub model_name: String,

    /// Token usage statistics for the request.
    pub usage: Usage,
}

/// Represents a structured response from a model after generating typed content.
///
/// This response type contains the parsed structured data of type `O` along with
/// metadata about the generation process.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StructuredResponse<O> {
    /// The parsed structured data returned by the model.
    pub data: O,

    /// The name of the vendor that provides the model (e.g., "google").
    pub vendor_name: String,

    /// The name of the model that generated the response.
    pub model_name: String,

    /// Token usage statistics for the request.
    pub usage: Usage,
}

impl ModelResponse {
    /// Converts the response message into a single text `String`.
    ///
    /// # Returns
    ///
    /// Returns `Some(String)` containing the concatenated text from all text parts,
    /// or `None` if no text parts are found.
    pub fn to_string(&self) -> Option<String> {
        let text_parts: Vec<&str> = self
            .message
            .content
            .iter()
            .filter_map(|part| match part {
                Part::Text { text, .. } => Some(text.as_str()),
                _ => None,
            })
            .collect();

        if text_parts.is_empty() {
            None
        } else {
            Some(text_parts.join(""))
        }
    }

    /// Converts the response message into a `Vec` of `ToolUse`s.
    ///
    /// # Returns
    ///
    /// Returns `Some(Vec<ToolUse>)` containing all tool calls found in the response,
    /// or `None` if no tool calls are found.
    pub fn to_tool_calls(&self) -> Option<Vec<ToolUse>> {
        let calls: Vec<ToolUse> = self
            .message
            .content
            .iter()
            .filter_map(|part| match part {
                Part::ToolUse { id, name, args, .. } => Some(ToolUse {
                    id: id.clone(),
                    name: name.clone(),
                    args: args.clone(),
                    ext: None,
                }),
                _ => None,
            })
            .collect();

        if calls.is_empty() { None } else { Some(calls) }
    }
}
